"""
Exploit Database Module for APT Toolkit

Features:
- Unified exploit database interface
- Local and remote exploit lookup
- Metadata extraction
- Thread-safe operations
- Integration with scanning modules

WARNING: This module should only be used for authorized security testing.
Misuse of exploits may violate laws and cause system damage.
"""

import json
import sqlite3
import threading
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from enum import Enum, auto
import requests
from concurrent.futures import ThreadPoolExecutor

from src.core.engine import ScanModule, ScanTarget, ScanResult, ScanStatus
from src.utils.logger import get_logger
from src.utils.file_utils import FileUtils
from src.utils.config import config
from src.core.event_system import event_system, Event

logger = get_logger(__name__)

class ExploitSource(Enum):
    """Exploit data sources"""
    LOCAL_DB = auto()
    REMOTE_API = auto()
    FILE_SYSTEM = auto()

class ExploitDB(ScanModule):
    """Unified exploit database interface"""
    
    def __init__(self):
        super().__init__()
        self.module_name = "exploit_db"
        self.local_db_path = Path(config.exploits.local_db_path)
        self.remote_api_url = config.exploits.remote_api_url
        self.max_threads = config.exploits.max_threads
        self._lock = threading.RLock()
        self._db_conn = None
        self._stop_event = threading.Event()
        
        # Initialize database connection
        self._init_db()
        
    def _init_db(self) -> None:
        """Initialize local exploit database connection"""
        if self.local_db_path.exists():
            try:
                self._db_conn = sqlite3.connect(str(self.local_db_path))
                logger.info(f"Connected to local exploit database at {self.local_db_path}")
            except sqlite3.Error as e:
                logger.error(f"Failed to connect to local exploit db: {str(e)}")
                
    def initialize(self) -> None:
        """Initialize module resources"""
        logger.info(f"Initialized {self.module_name} with {self.max_threads} threads")
        event_system.register("exploit_search", self._handle_search_request)
        
    def cleanup(self) -> None:
        """Cleanup module resources"""
        self._stop_event.set()
        if self._db_conn:
            self._db_conn.close()
        logger.info(f"Cleaned up {self.module_name}")
        
    def validate_target(self, target: ScanTarget) -> bool:
        """Validate target is appropriate for exploit lookup"""
        return bool(target.metadata.get("cve") or target.metadata.get("query"))
        
    def _search_local_db(self, query: str) -> List[Dict[str, Any]]:
        """Search local exploit database"""
        results = []
        if not self._db_conn:
            return results
            
        try:
            cursor = self._db_conn.cursor()
            cursor.execute(
                "SELECT id, cve, title, platform, type, path FROM exploits WHERE title LIKE ? OR cve LIKE ?",
                (f"%{query}%", f"%{query}%")
            )
            for row in cursor.fetchall():
                results.append({
                    "id": row[0],
                    "cve": row[1],
                    "title": row[2],
                    "platform": row[3],
                    "type": row[4],
                    "path": row[5],
                    "source": ExploitSource.LOCAL_DB.name
                })
        except sqlite3.Error as e:
            logger.error(f"Local DB search failed: {str(e)}")
            
        return results
        
    def _search_remote_api(self, query: str) -> List[Dict[str, Any]]:
        """Search remote exploit database API"""
        results = []
        if not self.remote_api_url:
            return results
            
        try:
            response = requests.get(
                f"{self.remote_api_url}/search",
                params={"q": query},
                timeout=10
            )
            if response.status_code == 200:
                for item in response.json().get("results", []):
                    results.append({
                        "id": item.get("id"),
                        "cve": item.get("cve"),
                        "title": item.get("title"),
                        "platform": item.get("platform"),
                        "source": ExploitSource.REMOTE_API.name
                    })
        except requests.exceptions.RequestException as e:
            logger.error(f"Remote API search failed: {str(e)}")
            
        return results
        
    def _get_exploit_details(self, exploit_id: str, source: ExploitSource) -> Optional[Dict[str, Any]]:
        """Retrieve complete exploit details"""
        try:
            if source == ExploitSource.LOCAL_DB and self._db_conn:
                cursor = self._db_conn.cursor()
                cursor.execute(
                    "SELECT * FROM exploits WHERE id = ?",
                    (exploit_id,)
                )
                row = cursor.fetchone()
                if row:
                    return {
                        "id": row[0],
                        "cve": row[1],
                        "title": row[2],
                        "platform": row[3],
                        "type": row[4],
                        "path": row[5],
                        "code": FileUtils.read_file(row[5]),
                        "source": source.name
                    }
                    
            elif source == ExploitSource.REMOTE_API:
                response = requests.get(
                    f"{self.remote_api_url}/exploits/{exploit_id}",
                    timeout=10
                )
                if response.status_code == 200:
                    return response.json()
                    
        except Exception as e:
            logger.error(f"Failed to get exploit details: {str(e)}")
            
        return None
        
    def _handle_search_request(self, event: Event, query: str) -> List[Dict[str, Any]]:
        """Handle exploit search requests"""
        results = []
        
        # Search local database
        results.extend(self._search_local_db(query))
        
        # Search remote API if local results are insufficient
        if not results and not self._stop_event.is_set():
            results.extend(self._search_remote_api(query))
            
        return results
        
    def execute(self, target: ScanTarget) -> ScanResult:
        """
        Search and retrieve exploits based on target parameters
        
        Args:
            target: ScanTarget specifying search criteria
            
        Returns:
            ScanResult with matching exploits
        """
        if not self.validate_target(target):
            logger.error("Invalid exploit search target")
            return ScanResult(
                target=target,
                data={"error": "Invalid target"},
                status=ScanStatus.FAILED
            )
            
        try:
            query = target.metadata.get("query", "")
            cve = target.metadata.get("cve", "")
            platform = target.metadata.get("platform", "")
            
            search_term = cve or query
            if not search_term:
                raise ValueError("Missing search query or CVE")
                
            logger.info(f"Searching exploits for: {search_term} (platform: {platform})")
            
            # Search across all sources
            futures = []
            results = []
            
            with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
                futures.append(executor.submit(self._search_local_db, search_term))
                futures.append(executor.submit(self._search_remote_api, search_term))
                
                for future in futures:
                    if self._stop_event.is_set():
                        break
                    try:
                        results.extend(future.result())
                    except Exception as e:
                        logger.error(f"Exploit search failed: {str(e)}")
                        
            # Filter by platform if specified
            if platform:
                results = [r for r in results if platform.lower() in r.get("platform", "").lower()]
                
            return ScanResult(
                target=target,
                data={
                    "query": search_term,
                    "platform": platform,
                    "count": len(results),
                    "results": results,
                    "sources": list(set(r["source"] for r in results))
                },
                status=ScanStatus.COMPLETED
            )
            
        except Exception as e:
            logger.error(f"Exploit database operation failed: {str(e)}", exc_info=True)
            return ScanResult(
                target=target,
                data={"error": str(e)},
                status=ScanStatus.FAILED
            )

# Module registration
def init_module():
    return ExploitDB()

# Example usage:
# db = ExploitDB()
# target = ScanTarget(
#     metadata={
#         "cve": "CVE-2023-1234",
#         "platform": "Linux"
#     }
# )
# result = db.execute(target)
# print(json.dumps(result.data, indent=2))